using JetBrains.Annotations;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Engine.User.Codegen.Generators;

[Generator]
public sealed class InputAliasGenerator : IIncrementalGenerator
{
    private const string MarkerAttribute = "Engine.Input.Attributes.InputActionsAttribute";
    
    public void Initialize(IncrementalGeneratorInitializationContext ctx)
    {
        var enumWithMarker =
            ctx.SyntaxProvider.ForAttributeWithMetadataName(
                    MarkerAttribute,
                    predicate: static (node, _) => node is EnumDeclarationSyntax,
                    transform: static (genCtx, _) =>
                        (INamedTypeSymbol)genCtx.TargetSymbol)   // ⇢ the enum symbol
                .Collect()                                         // gather them
                .Select(static (list, _) => list.FirstOrDefault()); // take the first (or choose)

        // 2.  Convert “symbol?” → “(bool found, string fqName)”
        var targetInfo = enumWithMarker.Select(static (sym, _) =>
            sym is null
                ? (found: false, fqName: "")
                : (found: true, fqName: sym.ToDisplayString()));

        // 3.  Emit the alias only when we actually found one.
        ctx.RegisterImplementationSourceOutput(
            targetInfo,
            static (spc, info) =>
            {
                if (!info.found) return;         // nothing marked ⇒ no alias ⇒ no CS0400

                spc.AddSource(
                    "OnInputAction.alias.g.cs",
                    $"""
                      // <auto-generated/>
                      global using OnInput = global::Engine.Input.Attributes.OnInputAttribute<global::{info.fqName}>;
                      global using OnInputHeld = global::Engine.Input.Attributes.OnInputHeldAttribute<global::{info.fqName}>;
                      global using OnInputReleased = global::Engine.Input.Attributes.OnInputReleasedAttribute<global::{info.fqName}>;
                      """);
            });
    }

    [UsedImplicitly]
    private static bool? GetInfo(GeneratorSyntaxContext cx)
    {
        if (cx.Node is not AttributeSyntax attr ||
            cx.SemanticModel.GetTypeInfo(attr).Type is not INamedTypeSymbol t)
            return null;

        return t.Name is "OnInputActionHeld" or "OnInputActionHeldAttribute" &&
               t.IsGenericType &&
               t.TypeArguments[0] is INamedTypeSymbol arg &&
               arg.ToDisplayString() is "User.Game.Actors.InputAction";
    }
}