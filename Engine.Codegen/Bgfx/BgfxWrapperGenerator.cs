
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Engine.Codegen.Bgfx;

// TODO: This is a little experiment that didn't work at all, fix later, maybe.
[Generator]
internal sealed class BgfxWrapperGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Locate the compiled bgfx binding symbol once per compilation.
        var bgfxSymbolProvider = context.CompilationProvider.Select(
            static (comp, _) => comp.GetTypeByMetadataName("Engine.Codegen.BgfxWrapper.Unsafe.bgfx"));

        context.RegisterSourceOutput(bgfxSymbolProvider, static (spc, bgfxSymbol) =>
        {
            if (bgfxSymbol is null)
                return; // bindings not found in this compilation

            // -----------------------------------------------------------------
            // 1. Collect method + struct metadata
            // -----------------------------------------------------------------
            var structs = GetAllNestedStructs(bgfxSymbol).ToArray();
            var methodSymbols = bgfxSymbol.GetMembers()
                                          .OfType<IMethodSymbol>()
                                          .Where(m => m.IsStatic && m.MethodKind == MethodKind.Ordinary)
                                          .ToArray();

            var wrapperMethodNames = new HashSet<string>(
                methodSymbols.Select(static m => ToPascal(m.Name)));

            var aliasNames = new HashSet<string>();

            // -----------------------------------------------------------------
            // 2. Emit aliases + wrappers
            // -----------------------------------------------------------------
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("using System;\nusing System.Runtime.InteropServices;");
            sb.AppendLine("namespace Engine.Codegen.Bgfx;\n");

            // 2a. Struct aliases (namespace-level).
            foreach (var structSymbol in structs)
            {
                var alias = BuildUniqueAlias(structSymbol, wrapperMethodNames, aliasNames);

                var target = structSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                sb.AppendLine($"using {alias} = {target};");
            }

            sb.AppendLine();

            // 2b. Wrapper class & methods
            sb.AppendLine("public static unsafe partial class Bgfx");
            sb.AppendLine("{");

            foreach (var method in methodSymbols)
            {
                var wrapperName = ToPascal(method.Name);
                var returnType  = method.ReturnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                string Param(IParameterSymbol p) =>
                    $"{RefPrefix(p)}{p.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} {p.Name}";

                string Arg(IParameterSymbol p) => $"{RefPrefix(p)}{p.Name}";

                var paramList = string.Join(", ", method.Parameters.Select(Param));
                var argList   = string.Join(", ", method.Parameters.Select(Arg));

                sb.AppendLine($"    public static {returnType} {wrapperName}({paramList}) => bgfx.{method.Name}({argList});");
            }

            sb.AppendLine("}\n");

            spc.AddSource("Bgfx.Generated.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        });
    }

    // -------------------------------------------------------------------------
    // Helpers
    // -------------------------------------------------------------------------

    private static IEnumerable<INamedTypeSymbol> GetAllNestedStructs(INamedTypeSymbol root)
    {
        var stack = new Stack<INamedTypeSymbol>();
        stack.Push(root);

        while (stack.Count > 0)
        {
            var current = stack.Pop();
            foreach (var nested in current.GetTypeMembers())
            {
                if (nested.TypeKind == TypeKind.Struct)
                    yield return nested;

                stack.Push(nested);
            }
        }
    }

    private static string BuildUniqueAlias(INamedTypeSymbol structSymbol,
                                            HashSet<string> wrapperMethodNames,
                                            HashSet<string> aliasNames)
    {
        var baseAlias = ToPascal(structSymbol.Name.TrimStart('_'));

        // Avoid clashing with wrapper methods
        if (wrapperMethodNames.Contains(baseAlias))
            baseAlias += "Struct";

        var alias = baseAlias;

        // Avoid clashing with other aliases – prefix with enclosing types until unique
        var parent = structSymbol.ContainingType;
        while (aliasNames.Contains(alias) && parent is not null)
        {
            alias = ToPascal(parent.Name.TrimStart('_')) + alias;
            parent = parent.ContainingType;
        }

        // Last-resort numeric suffix
        if (aliasNames.Contains(alias))
        {
            var i = 2;
            while (aliasNames.Contains(alias + i))
                i++;
            alias += i;
        }

        aliasNames.Add(alias);
        return alias;
    }

    private static string RefPrefix(IParameterSymbol p) => p.RefKind switch
    {
        RefKind.Ref => "ref ",
        RefKind.Out => "out ",
        RefKind.In  => "in ",
        _           => string.Empty
    };

    private static string ToPascal(string snake)
    {
        var parts = snake.Split('_');
        var sb = new StringBuilder(parts.Length * 8);

        foreach (var part in parts)
        {
            var span = part.AsSpan();
            if (span.IsEmpty) continue;

            sb.Append(char.ToUpperInvariant(span[0]));
            sb.Append(span.Slice(1).ToString().ToLowerInvariant());
        }

        return sb.ToString();
    }
}